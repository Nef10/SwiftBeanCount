{"metadata":{"modules":[{"name":"ArgumentParser"}],"roleHeading":"Article","role":"article","title":"Defining Commands and Subcommands"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/commandsandsubcommands"]}],"kind":"article","hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"],["doc:\/\/ArgumentParser\/documentation\/ArgumentParser","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand"]]},"abstract":[{"text":"Break complex command-line tools into a tree of subcommands.","type":"text"}],"seeAlsoSections":[{"anchor":"Essentials","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"],"title":"Essentials","generated":true}],"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"When command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as "},{"type":"codeVoice","code":"git"},{"type":"text","text":" and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as "},{"type":"codeVoice","code":"git branch"},{"type":"text","text":" or "},{"type":"codeVoice","code":"swift package init"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Generally, these subcommands each have their own configuration options, as well as options that are shared across several or all aspects of the larger program."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can build a program with commands and subcommands by defining multiple command types and specifying each command’s subcommands in its configuration. For example, here’s the interface of a "},{"code":"math","type":"codeVoice"},{"type":"text","text":" utility that performs operations on a series of values given on the command line."}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% math add 10 15 7","32","% math multiply 10 15 7","1050","% math stats average 3 4 13 15 15","10.0","% math stats average --kind median 3 4 13 15 15","13.0","% math stats","OVERVIEW: Calculate descriptive statistics.","","USAGE: math stats <subcommand>","","OPTIONS:","  -h, --help              Show help information.","","SUBCOMMANDS:","  average, avg            Print the average of the values.","  stdev                   Print the standard deviation of the values.","  quantiles               Print the quantiles of the values (TBD).","","  See 'math help stats <subcommand>' for detailed help."]},{"inlineContent":[{"type":"text","text":"Start by defining the root "},{"type":"codeVoice","code":"Math"},{"type":"text","text":" command. You can provide a static "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration","isActive":true},{"type":"text","text":" property for a command that specifies its subcommands and a default subcommand, if any."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Math: ParsableCommand {","    static let configuration = CommandConfiguration(","        abstract: \"A utility for performing maths.\",","        subcommands: [Add.self, Multiply.self, Statistics.self],","        defaultSubcommand: Add.self)","}"]},{"inlineContent":[{"type":"codeVoice","code":"Math"},{"type":"text","text":" lists its three subcommands by their types; we’ll see the definitions of "},{"type":"codeVoice","code":"Add"},{"type":"text","text":", "},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" below. "},{"type":"codeVoice","code":"Add"},{"type":"text","text":" is also given as a default subcommand — this means that it is selected if a user leaves out a subcommand name:"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% math 10 15 7","32"]},{"inlineContent":[{"type":"text","text":"Next, define a "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","isActive":true},{"type":"text","text":" type with properties that will be shared across multiple subcommands. Types that conform to "},{"code":"ParsableArguments","type":"codeVoice"},{"type":"text","text":" can be parsed from command-line arguments, but don’t provide any execution through a "},{"code":"run()","type":"codeVoice"},{"type":"text","text":" method."}],"type":"paragraph"},{"inlineContent":[{"text":"In this case, the ","type":"text"},{"type":"codeVoice","code":"Options"},{"text":" type accepts a ","type":"text"},{"type":"codeVoice","code":"--hexadecimal-output"},{"text":" flag and expects a list of integers.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Options: ParsableArguments {","    @Flag(name: [.long, .customShort(\"x\")], help: \"Use hexadecimal notation for the result.\")","    var hexadecimalOutput = false","","    @Argument(help: \"A group of integers to operate on.\")","    var values: [Int]","}"]},{"inlineContent":[{"type":"text","text":"It’s time to define our first two subcommands: "},{"type":"codeVoice","code":"Add"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":". Both of these subcommands include the arguments defined in the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type by denoting that property with the "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" property wrapper (see "},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","type":"reference","isActive":true},{"type":"text","text":"). "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" doesn’t define any new arguments for a command; instead, it splats in the arguments defined by another "},{"type":"codeVoice","code":"ParsableArguments"},{"type":"text","text":" type."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Math {","    struct Add: ParsableCommand {","        static let configuration","            = CommandConfiguration(abstract: \"Print the sum of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(0, +)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","","    struct Multiply: ParsableCommand {","        static let configuration = CommandConfiguration(","            abstract: \"Print the product of the values.\",","            aliases: [\"mul\"])","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(1, *)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","}"]},{"inlineContent":[{"text":"One thing to note is the aliases parameter for ","type":"text"},{"type":"codeVoice","code":"CommandConfiguration"},{"text":". This is useful for subcommands","type":"text"},{"text":" ","type":"text"},{"text":"to define alternative names that can be used to invoke them. In this case we’ve defined a shorthand","type":"text"},{"text":" ","type":"text"},{"text":"for multiply named mul, so you could invoke the ","type":"text"},{"type":"codeVoice","code":"Multiply"},{"text":" command for our program by either of the below:","type":"text"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% math multiply 10 15 7","1050","% math mul 10 15 7","1050"]},{"inlineContent":[{"type":"text","text":"Next, we’ll define "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":", the third subcommand of "},{"type":"codeVoice","code":"Math"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" command specifies a custom command name ("},{"type":"codeVoice","code":"stats"},{"type":"text","text":") in its configuration, overriding the default derived from the type name ("},{"type":"codeVoice","code":"statistics"},{"type":"text","text":"). It also declares two additional subcommands, meaning that it acts as a forked branch in the command tree, and not a leaf."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Math {","    struct Statistics: ParsableCommand {","        static let configuration = CommandConfiguration(","            commandName: \"stats\",","            abstract: \"Calculate descriptive statistics.\",","            subcommands: [Average.self, StandardDeviation.self])","    }","}"]},{"inlineContent":[{"type":"text","text":"Let’s finish our subcommands with the "},{"type":"codeVoice","code":"Average"},{"type":"text","text":" and "},{"type":"codeVoice","code":"StandardDeviation"},{"type":"text","text":" types. Each of them has slightly different arguments, so they don’t use the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type defined above. Each subcommand is ultimately independent and can specify a combination of shared and unique arguments."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension Math.Statistics {","    struct Average: ParsableCommand {","        static let configuration = CommandConfiguration(","            abstract: \"Print the average of the values.\",","            aliases: [\"avg\"])","","        enum Kind: String, ExpressibleByArgument {","            case mean, median, mode","        }","","        @Option(help: \"The kind of average to provide.\")","        var kind: Kind = .mean","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        func calculateMean() -> Double { ... }","        func calculateMedian() -> Double { ... }","        func calculateMode() -> [Double] { ... }","","        mutating func run() {","            switch kind {","            case .mean:","                print(calculateMean())","            case .median:","                print(calculateMedian())","            case .mode:","                let result = calculateMode()","                    .map(String.init(describing:))","                    .joined(separator: \" \")","                print(result)","            }","        }","    }","","    struct StandardDeviation: ParsableCommand {","        static let configuration = CommandConfiguration(","            commandName: \"stdev\",","            abstract: \"Print the standard deviation of the values.\")","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        mutating func run() {","            if values.isEmpty {","                print(0.0)","            } else {","                let sum = values.reduce(0, +)","                let mean = sum \/ Double(values.count)","                let squaredErrors = values","                    .map { $0 - mean }","                    .map { $0 * $0 }","                let variance = squaredErrors.reduce(0, +) \/ Double(values.count)","                let result = variance.squareRoot()","                print(result)","            }","        }","    }","}"]},{"inlineContent":[{"type":"text","text":"Last but not least, we add the "},{"type":"codeVoice","code":"@main"},{"type":"text","text":" attribute to the root of our command tree, to tell the compiler to use that as the program’s entry point. Upon execution, this parses the command-line arguments, determines whether a subcommand was selected, and then instantiates and calls the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method on that particular subcommand."}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"The Swift compiler uses either the type marked with ","type":"text"},{"type":"codeVoice","code":"@main"},{"text":" or a ","type":"text"},{"type":"codeVoice","code":"main.swift"},{"text":" file as the entry point for an executable program. You can use either one, but not both — rename your ","type":"text"},{"type":"codeVoice","code":"main.swift"},{"text":" file to the name of your command when you add ","type":"text"},{"type":"codeVoice","code":"@main"},{"text":". In this case, rename it to ","type":"text"},{"type":"codeVoice","code":"Math.swift"},{"text":".","type":"text"}]}],"name":"Note"},{"syntax":"swift","type":"codeListing","code":["@main","struct Math: ParsableCommand {","    \/\/ ...","}"]},{"inlineContent":[{"text":"That’s it for this doubly-nested ","type":"text"},{"type":"codeVoice","code":"math"},{"type":"text","text":" command! This example is also provided as a part of the "},{"type":"codeVoice","code":"swift-argument-parser"},{"type":"text","text":" repository, so you can see it all together and experiment with it "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift"},{"type":"text","text":"."}],"type":"paragraph"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","interfaceLanguage":"swift"},"references":{"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","type":"topic","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"url":"\/documentation\/argumentparser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"kind":"article","title":"Customizing Help for Commands","abstract":[{"text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display.","type":"text"}],"url":"\/documentation\/argumentparser\/customizingcommandhelp","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","role":"article"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"navigatorTitle":[{"text":"ParsableCommand","kind":"identifier"}],"title":"ParsableCommand","url":"\/documentation\/argumentparser\/parsablecommand","abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParsableCommand","kind":"identifier"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","type":"topic","role":"symbol","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand/configuration":{"type":"topic","required":true,"title":"configuration","abstract":[{"text":"Configuration for this command, including subcommands and custom help","type":"text"},{"text":" ","type":"text"},{"text":"text.","type":"text"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand\/configuration","defaultImplementations":1,"role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"configuration"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser20CommandConfigurationV","text":"CommandConfiguration"}],"url":"\/documentation\/argumentparser\/parsablecommand\/configuration","kind":"symbol"},"https://github.com/apple/swift-argument-parser/blob/main/Examples/math/Math.swift":{"url":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift","titleInlineContent":[{"text":"here","type":"text"}],"type":"link","title":"here","identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/Math.swift"},"doc://ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncParsableCommand"}],"url":"\/documentation\/argumentparser\/asyncparsablecommand","abstract":[{"text":"A type that can be executed asynchronously, as part of a nested tree of","type":"text"},{"text":" ","type":"text"},{"text":"commands.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"AsyncParsableCommand"}],"role":"symbol","title":"AsyncParsableCommand"},"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OptionGroup","kind":"identifier"}],"kind":"symbol","title":"OptionGroup","abstract":[{"text":"A wrapper that transparently includes a parsable type.","type":"text"}],"url":"\/documentation\/argumentparser\/optiongroup","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","type":"topic","navigatorTitle":[{"text":"OptionGroup","kind":"identifier"}]},"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/argumentparser\/parsablearguments","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableArguments"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","title":"ParsableArguments","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}],"navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}]},"doc://ArgumentParser/documentation/ArgumentParser/GettingStarted":{"abstract":[{"text":"Learn to set up and customize a simple command-line tool.","type":"text"}],"url":"\/documentation\/argumentparser\/gettingstarted","role":"article","kind":"article","type":"topic","title":"Getting Started with ArgumentParser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted"}}}