{"sections":[],"abstract":[{"text":"Learn to set up and customize a simple command-line tool.","type":"text"}],"kind":"article","primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This guide walks through building an example command. You’ll learn about the different tools that "},{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" provides for defining a command’s options, customizing the interface, and providing help text for your user."}]},{"type":"heading","level":3,"text":"Adding ArgumentParser as a Dependency","anchor":"Adding-ArgumentParser-as-a-Dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s write a tool called "},{"type":"codeVoice","code":"count"},{"type":"text","text":" that reads an input file, counts the words, and writes the result to an output file."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, we need to add "},{"type":"codeVoice","code":"swift-argument-parser"},{"type":"text","text":" as a dependency to our package,"},{"type":"text","text":" "},{"type":"text","text":"and then include "},{"type":"codeVoice","code":"\"ArgumentParser\""},{"type":"text","text":" as a dependency for our executable target."},{"type":"text","text":" "},{"type":"text","text":"Our “Package.swift” file ends up looking like this:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ swift-tools-version:5.7","import PackageDescription","","let package = Package(","    name: \"Count\",","    dependencies: [","        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser.git\", from: \"1.3.0\"),","    ],","    targets: [","        .executableTarget(","            name: \"count\",","            dependencies: [.product(name: \"ArgumentParser\", package: \"swift-argument-parser\")]),","    ]",")"]},{"type":"heading","level":3,"text":"Building Our First Command","anchor":"Building-Our-First-Command"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we’ve built the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool, we’ll be able to run it like this:"}]},{"type":"codeListing","syntax":null,"code":["% count readme.md readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"type":"paragraph","inlineContent":[{"text":"We’ll define the initial version of the command as a type that conforms to the ","type":"text"},{"code":"ParsableCommand","type":"codeVoice"},{"text":" protocol:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["import ArgumentParser","","@main","struct Count: ParsableCommand {","    @Argument var inputFile: String","    @Argument var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" and "},{"type":"codeVoice","code":"outputFile"},{"type":"text","text":" properties use the "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":" property wrapper. "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" uses this wrapper to denote a positional command-line input — because "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" is specified first in the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type, it’s the first value read from the command line, and "},{"type":"codeVoice","code":"outputFile"},{"type":"text","text":" is the second."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The command’s logic is implemented in its "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method. Here, it prints out a message confirming the names of the files the user gave. (You can find a full implementation of the completed command at the end of this guide.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" command is designated as the program’s entry point by applying the "},{"type":"codeVoice","code":"@main"},{"type":"text","text":" attribute. When running your command, the "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" library parses the command-line arguments, verifies that they match up with what we’ve defined in "},{"type":"codeVoice","code":"Count"},{"type":"text","text":", and either calls the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method or exits with a helpful message."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"The Swift compiler uses either the type marked with ","type":"text"},{"code":"@main","type":"codeVoice"},{"text":" or a ","type":"text"},{"code":"main.swift","type":"codeVoice"},{"text":" file as the entry point for an executable program. You can use either one, but not both — rename your ","type":"text"},{"code":"main.swift","type":"codeVoice"},{"text":" file to the name of the command when you add ","type":"text"},{"code":"@main","type":"codeVoice"},{"text":". In this case, rename the file to ","type":"text"},{"code":"Count.swift","type":"codeVoice"},{"text":".","type":"text"}]}],"type":"aside","name":"Note"},{"anchor":"Working-with-Named-Options","level":3,"type":"heading","text":"Working with Named Options"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool may have a usability problem — it’s not immediately clear whether a user should provide the input file first, or the output file. Instead of using positional arguments for our two inputs, let’s specify that they should be labeled options:"}]},{"code":["% count --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"We do this by using the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" property wrapper instead of "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":":"}]},{"code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"@Option","type":"codeVoice"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"code":"--name <value>","type":"codeVoice"},{"type":"text","text":", deriving its name from the name of your property."}]},{"inlineContent":[{"type":"text","text":"This interface has a trade-off for the users of our "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool: With "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":", users don’t need to type as much, but they have to remember whether to provide the input file or the output file first. Using "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" makes the user type a little more, but the distinction between values is explicit. Options are order-independent, as well, so the user can name the input and output files in either order:"}],"type":"paragraph"},{"syntax":null,"code":["% count --output-file readme.counts --input-file readme.md","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing"},{"text":"Adding a Flag","anchor":"Adding-a-Flag","level":3,"type":"heading"},{"inlineContent":[{"text":"Next, we want to add a ","type":"text"},{"type":"codeVoice","code":"--verbose"},{"text":" flag to our tool, and only print the message if the user specifies that option:","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["% count --input-file readme.md --output-file readme.counts","(no output)","% count --verbose --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Let’s change our "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type to look like this:"}],"type":"paragraph"},{"syntax":"swift","code":["@main","struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    @Flag var verbose = false","    ","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"type":"codeVoice","code":"--name"},{"type":"text","text":", deriving its name from the name of your property. Flags are most frequently used for Boolean values, like the "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" property here."}],"type":"paragraph"},{"text":"Using Custom Names","anchor":"Using-Custom-Names","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"We can customize the names of our options and add an alternative to the "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" flag so that users can specify "},{"type":"codeVoice","code":"-v"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":". The new interface will look like this:"}],"type":"paragraph"},{"syntax":null,"code":["% count -v -i readme.md -o readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count --input readme.md --output readme.counts -v","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count -o readme.counts -i readme.md --verbose","Counting words in 'readme.md' and writing the result into 'readme.counts'."],"type":"codeListing"},{"inlineContent":[{"text":"Customize the input names by passing ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" parameters to the ","type":"text"},{"code":"@Option","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"@Flag","type":"codeVoice"},{"text":" initializers:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")])","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")])","    var outputFile: String","","    @Flag(name: .shortAndLong)","    var verbose = false","    ","    mutating func run() throws { ... }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The default name specification is ","type":"text"},{"code":".long","type":"codeVoice"},{"text":", which uses a property’s name with a two-dash prefix. ","type":"text"},{"code":".short","type":"codeVoice"},{"text":" uses only the first letter of a property’s name with a single-dash prefix, and allows combining groups of short options. You can specify custom short and long names with the ","type":"text"},{"code":".customShort(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".customLong(_:)","type":"codeVoice"},{"text":" methods, respectively, or use the combined ","type":"text"},{"code":".shortAndLong","type":"codeVoice"},{"text":" property to specify the common case of both the short and long derived names.","type":"text"}],"type":"paragraph"},{"text":"Providing Help","anchor":"Providing-Help","level":3,"type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" automatically generates help for any command when a user provides the "},{"type":"codeVoice","code":"-h"},{"type":"text","text":" or "},{"type":"codeVoice","code":"--help"},{"type":"text","text":" flags:"}],"type":"paragraph"},{"syntax":null,"code":["% count --help","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>      ","  -o, --output <output>    ","  -v, --verbose            ","  -h, --help              Show help information."],"type":"codeListing"},{"inlineContent":[{"text":"This is a great start — you can see that all the custom names are visible, and the help shows that values are expected for the ","type":"text"},{"code":"--input","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"--output","type":"codeVoice"},{"text":" options. However, our custom options and flag don’t have any descriptive text. Let’s add that now by passing string literals as the ","type":"text"},{"code":"help","type":"codeVoice"},{"text":" parameter:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@main","struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws { ... }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The help screen now includes descriptions for each parameter:"}],"type":"paragraph"},{"syntax":null,"code":["% count -h","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>     A file to read. ","  -o, --output <output>   A file to save word counts to. ","  -v, --verbose           Print status updates while counting. ","  -h, --help              Show help information.",""],"type":"codeListing"},{"text":"The Complete Utility","anchor":"The-Complete-Utility","level":3,"type":"heading"},{"inlineContent":[{"text":"As promised, here’s the complete ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" command, for your experimentation:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["import ArgumentParser","import Foundation","","@main","struct Count: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Word counter.\")","    ","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        guard let input = try? String(contentsOfFile: inputFile) else {","            throw RuntimeError(\"Couldn't read from '\\(inputFile)'!\")","        }","        ","        let words = input.components(separatedBy: .whitespacesAndNewlines)","            .map { word in","                word.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)","                    .lowercased()","            }","            .compactMap { word in word.isEmpty ? nil : word }","        ","        let counts = Dictionary(grouping: words, by: { $0 })","            .mapValues { $0.count }","            .sorted(by: { $0.value > $1.value })","        ","        if verbose {","            print(\"Found \\(counts.count) words.\")","        }","        ","        let output = counts.map { word, count in \"\\(word): \\(count)\" }","            .joined(separator: \"\\n\")","        ","        guard let _ = try? output.write(toFile: outputFile, atomically: true, encoding: .utf8) else {","            throw RuntimeError(\"Couldn't write to '\\(outputFile)'!\")","        }","    }","}","","struct RuntimeError: Error, CustomStringConvertible {","    var description: String","    ","    init(_ description: String) {","        self.description = description","    }","}"],"type":"codeListing"},{"text":"Next Steps … Swift concurrency","anchor":"Next-Steps--Swift-concurrency","level":3,"type":"heading"},{"inlineContent":[{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" supports Swift concurrency, notably "},{"type":"codeVoice","code":"async"},{"type":"text","text":" renditions of "},{"type":"codeVoice","code":"run"},{"type":"text","text":". If you use "},{"type":"codeVoice","code":"async"},{"type":"text","text":" rendition of "},{"type":"codeVoice","code":"run"},{"type":"text","text":", conform to "},{"type":"codeVoice","code":"AsyncParsableCommand"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"ParsableCommand"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["@main","struct FileUtility: AsyncParsableCommand {","    @Argument(","        help: \"File to be parsed.\",","        transform: URL.init(fileURLWithPath:)","    )","    var file: URL","","    mutating func run() async throws {","        let handle = try FileHandle(forReadingFrom: file)","","        for try await line in handle.bytes.lines {","            \/\/ do something with each line","        }","","        try handle.close()","    }","}"],"type":"codeListing"},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you accidentally use "},{"type":"codeVoice","code":"ParsableCommand"},{"type":"text","text":" with an "},{"type":"codeVoice","code":"async"},{"type":"text","text":" rendition of "},{"type":"codeVoice","code":"run"},{"type":"text","text":", the app may never reach your "},{"type":"codeVoice","code":"run"},{"type":"text","text":" function and may only show the "},{"type":"codeVoice","code":"USAGE"},{"type":"text","text":" text. If you are using "},{"type":"codeVoice","code":"async"},{"type":"text","text":" version of "},{"type":"codeVoice","code":"run"},{"type":"text","text":", you must use "},{"type":"codeVoice","code":"AsyncParsableCommand"},{"type":"text","text":"."}]}],"style":"note","type":"aside"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted"},"variants":[{"paths":["\/documentation\/argumentparser\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"metadata":{"title":"Getting Started with ArgumentParser","role":"article","roleHeading":"Article","modules":[{"name":"ArgumentParser"}]},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"seeAlsoSections":[{"anchor":"Essentials","generated":true,"title":"Essentials","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp"]}],"references":{"doc://ArgumentParser/documentation/ArgumentParser/CommandsAndSubcommands":{"role":"article","url":"\/documentation\/argumentparser\/commandsandsubcommands","type":"topic","kind":"article","abstract":[{"text":"Break complex command-line tools into a tree of subcommands.","type":"text"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","title":"Defining Commands and Subcommands"},"doc://ArgumentParser/documentation/ArgumentParser/AsyncParsableCommand":{"kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/AsyncParsableCommand","type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncParsableCommand"}],"url":"\/documentation\/argumentparser\/asyncparsablecommand","abstract":[{"text":"A type that can be executed asynchronously, as part of a nested tree of","type":"text"},{"text":" ","type":"text"},{"text":"commands.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"AsyncParsableCommand"}],"role":"symbol","title":"AsyncParsableCommand"},"doc://ArgumentParser/documentation/ArgumentParser/CustomizingCommandHelp":{"kind":"article","title":"Customizing Help for Commands","abstract":[{"text":"Define your command’s abstract, extended discussion, or usage string, and set the flags used to invoke the help display.","type":"text"}],"url":"\/documentation\/argumentparser\/customizingcommandhelp","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CustomizingCommandHelp","role":"article"},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","type":"topic","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"url":"\/documentation\/argumentparser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"navigatorTitle":[{"text":"ParsableCommand","kind":"identifier"}],"title":"ParsableCommand","url":"\/documentation\/argumentparser\/parsablecommand","abstract":[{"text":"A type that can be executed as part of a nested tree of commands.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ParsableCommand","kind":"identifier"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","type":"topic","role":"symbol","kind":"symbol"}}}