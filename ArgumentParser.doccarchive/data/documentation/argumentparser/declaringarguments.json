{"metadata":{"roleHeading":"Article","modules":[{"name":"ArgumentParser"}],"role":"article","title":"Declaring Arguments, Options, and Flags"},"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","text":"Overview","level":2,"type":"heading"},{"inlineContent":[{"text":"When creating commands, you can define three primary kinds of command-line inputs:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Arguments","type":"text"}]},{"type":"text","text":" are values given by a user and are read in order from first to last (see "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","isActive":true},{"type":"text","text":"). For example, this command is called with three file names as arguments:"}]},{"syntax":null,"type":"codeListing","code":["% example file1.swift file2.swift file3.swift"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Options"}]},{"type":"text","text":" are named key-value pairs. Keys start with one or two dashes ("},{"type":"codeVoice","code":"-"},{"type":"text","text":" or "},{"type":"codeVoice","code":"--"},{"type":"text","text":"), and a user can separate the key and value with an equal sign ("},{"type":"codeVoice","code":"="},{"type":"text","text":") or a space (see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option"},{"type":"text","text":"). This command is called with two options:"}]},{"syntax":null,"type":"codeListing","code":["% example --count=5 --index 2"]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Flags"}],"type":"emphasis"},{"type":"text","text":" are like options, but without a paired value. Instead, their presence indicates a particular value (see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag"},{"type":"text","text":"). This command is called with two flags:"}]},{"syntax":null,"type":"codeListing","code":["% example --verbose --strip-whitespace"]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The three preceding examples could be calls of this "},{"code":"Example","type":"codeVoice"},{"type":"text","text":" command:"}],"type":"paragraph"},{"code":["struct Example: ParsableCommand {","    @Argument var files: [String] = []","    @Option var count: Int?","    @Option var index = 0","    @Flag var verbose = false","    @Flag var stripWhitespace = false","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example shows how "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" provides defaults that speed up your initial development process:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Option and flag names are derived from the names of your command’s properties.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"What kinds of inputs are valid, and whether arguments are required, is based on your properties’ types and default values."}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"In this example, all of the properties have default values (optional properties default to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Users must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key "},{"code":"--user-name","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["struct Example: ParsableCommand {","    @Option var userName: String","    @Argument var value: Int","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"When called without both values, the command exits with an error:"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["% example 5","Error: Missing '--user-name <user-name>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information.","% example --user-name kjohnson","Error: Missing '<value>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When providing a default value for an array property, any user-supplied values replace the entire default."}]},{"syntax":"swift","type":"codeListing","code":["struct Lucky: ParsableCommand {","    @Argument var numbers = [7, 14, 21]","","    mutating func run() throws {","        print(\"\"\"","        Your lucky numbers are:","        \\(numbers.map(String.init).joined(separator: \" \"))","        \"\"\")","    }","}"]},{"syntax":null,"type":"codeListing","code":["% lucky ","Your lucky numbers are:","7 14 21","% lucky 1 2 3","Your lucky numbers are:","1 2 3"]},{"anchor":"Customizing-option-and-flag-names","type":"heading","level":3,"text":"Customizing option and flag names"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, options and flags derive the name that you use on the command line from the name of the property, such as "},{"type":"codeVoice","code":"--count"},{"type":"text","text":" and "},{"type":"codeVoice","code":"--index"},{"type":"text","text":". Camel-case names are converted to lowercase with hyphen-separated words, like "},{"type":"codeVoice","code":"--strip-whitespace"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can override this default by specifying one or more name specifications in the ","type":"text"},{"type":"codeVoice","code":"@Option"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"@Flag"},{"text":" initializers. This command demonstrates the four name specifications:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag(name: .long)  \/\/ Same as the default","    var stripWhitespace = false","","    @Flag(name: .short)","    var verbose = false","","    @Option(name: .customLong(\"count\"))","    var iterationCount: Int","","    @Option(name: [.customShort(\"I\"), .long])","    var inputFile: String","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Specifying ","type":"text"},{"type":"codeVoice","code":".long"},{"text":" or ","type":"text"},{"type":"codeVoice","code":".short"},{"text":" uses the property’s name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the ","type":"text"},{"type":"codeVoice","code":"stripWhitespace"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"verbose"},{"text":" flags are specified in this way:","type":"text"}]},{"type":"codeListing","code":["% example --strip-whitespace -v"],"syntax":null}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Specifying ","type":"text"},{"code":".customLong(_:)","type":"codeVoice"},{"text":" or ","type":"text"},{"code":".customShort(_:)","type":"codeVoice"},{"text":" uses the given string or character as the long or short name for the property.","type":"text"}]},{"type":"codeListing","syntax":null,"code":["% example --count 10 -I file1.swift"]}]},{"content":[{"inlineContent":[{"type":"text","text":"Use array literal syntax to specify multiple names. The "},{"code":"inputFile","type":"codeVoice"},{"type":"text","text":" property can alternatively be given with the default long name:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["% example --input-file file1.swift"]}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Note:"}],"type":"strong"},{"text":" You can also pass ","type":"text"},{"code":"withSingleDash: true","type":"codeVoice"},{"text":" to ","type":"text"},{"code":".customLong","type":"codeVoice"},{"text":" to create a single-dash flag or option, such as ","type":"text"},{"code":"-verbose","type":"codeVoice"},{"text":". Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether ","type":"text"},{"code":"-file","type":"codeVoice"},{"text":" is a single option or the combination of the four short options ","type":"text"},{"code":"-f","type":"codeVoice"},{"text":", ","type":"text"},{"code":"-i","type":"codeVoice"},{"text":", ","type":"text"},{"code":"-l","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"-e","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"heading","level":3,"text":"Parsing custom types","anchor":"Parsing-custom-types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Arguments and options can be parsed from any type that conforms to the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument"},{"type":"text","text":" protocol. Standard library integer and floating-point types, strings, and Booleans all conform to "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can make your own custom types conform to ","type":"text"},{"code":"ExpressibleByArgument","type":"codeVoice"},{"text":" by implementing ","type":"text"},{"isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)","type":"reference"},{"text":":","type":"text"}]},{"type":"codeListing","code":["struct Path: ExpressibleByArgument {","    var pathString: String","","    init?(argument: String) {","        self.pathString = argument","    }","}","","struct Example: ParsableCommand {","    @Argument var inputFile: Path","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The library provides a default implementation for ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"text":" types, like string-backed enumerations, so you only need to declare conformance.","type":"text"}]},{"type":"codeListing","code":["enum ReleaseMode: String, ExpressibleByArgument {","    case debug, release","}","","struct Example: ParsableCommand {","    @Option var mode: ReleaseMode","","    mutating func run() throws {","        print(mode)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:"}]},{"type":"codeListing","code":["% example --mode release","release","% example --mode future","Error: The value 'future' is invalid for '--mode <mode>'"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"To use a non-","type":"text"},{"code":"ExpressibleByArgument","type":"codeVoice"},{"text":" type for an argument or option, you can instead provide a throwing ","type":"text"},{"code":"transform","type":"codeVoice"},{"text":" function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a ","type":"text"},{"code":"RawRepresentable","type":"codeVoice"},{"text":" type, or for types you don’t define yourself.","type":"text"}]},{"type":"codeListing","code":["enum Format {","    case text","    case other(String)","","    init(_ string: String) throws {","        if string == \"text\" {","            self = .text","        } else {","            self = .other(string)","        }","    }","}","","struct Example: ParsableCommand {","    @Argument(transform: Format.init)","    var format: Format","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Throw an error from the "},{"type":"codeVoice","code":"transform"},{"type":"text","text":" function to indicate that the user provided an invalid value for that type. See "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation","isActive":true},{"type":"text","text":" for more about customizing "},{"type":"codeVoice","code":"transform"},{"type":"text","text":" function errors."}]},{"type":"heading","level":3,"text":"Using flag inversions, enumerations, and counts","anchor":"Using-flag-inversions-enumerations-and-counts"},{"type":"paragraph","inlineContent":[{"text":"Flags are most frequently used for ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" properties. You can generate a ","type":"text"},{"type":"codeVoice","code":"true"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"false"},{"text":" pair of flags by specifying a flag inversion:","type":"text"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag(inversion: .prefixedNo)","    var index = true","","    @Flag(inversion: .prefixedEnableDisable)","    var requiredElement: Bool","","    mutating func run() throws {","        print(index, requiredElement)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"When declaring a flag with an inversion, set the default by specifying ","type":"text"},{"type":"codeVoice","code":"true"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"false"},{"text":" as the property’s initial value. If you want to require that the user specify one of the two inversions, leave off the default value.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In the ","type":"text"},{"type":"codeVoice","code":"Example"},{"text":" command defined above, a flag is required for the ","type":"text"},{"type":"codeVoice","code":"requiredElement"},{"text":" property. The specified prefixes are prepended to the long names for the flags:","type":"text"}]},{"type":"codeListing","code":["% example --enable-required-element","true true","% example --no-index --disable-required-element","false false","% example --index","Error: Missing one of: '--enable-required-element', '--disable-required-element'"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"To create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the ","type":"text"},{"type":"codeVoice","code":"EnumerableFlag"},{"text":" protocol.","type":"text"}]},{"type":"codeListing","code":["enum CacheMethod: String, EnumerableFlag {","    case inMemoryCache","    case persistentCache","}","","enum Color: String, EnumerableFlag {","    case pink, purple, silver","}","","struct Example: ParsableCommand {","    @Flag var cacheMethod: CacheMethod","    @Flag var colors: [Color] = []","","    mutating func run() throws {","        print(cacheMethod)","        print(colors)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","isActive":true},{"type":"text","text":" documentation."}]},{"type":"codeListing","code":["% example --in-memory-cache --pink --silver",".inMemoryCache","[.pink, .silver]","% example","Error: Missing one of: '--in-memory-cache', '--persistent-cache'"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"Finally, when a flag is of type ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":", the value is parsed as a count of the number of times that the flag is specified.","type":"text"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag(name: .shortAndLong)","    var verbose: Int","","    mutating func run() throws {","        print(\"Verbosity level: \\(verbose)\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, "},{"code":"verbose","type":"codeVoice"},{"type":"text","text":" defaults to zero, and counts the number of times that "},{"code":"-v","type":"codeVoice"},{"type":"text","text":" or "},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":" is given."}]},{"type":"codeListing","code":["% example --verbose","Verbosity level: 1","% example -vvvv","Verbosity level: 4"],"syntax":null},{"type":"heading","level":3,"text":"Specifying default values","anchor":"Specifying-default-values"},{"type":"paragraph","inlineContent":[{"text":"You can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:","type":"text"}]},{"type":"codeListing","code":["enum CustomFlag: String, EnumerableFlag {","    case foo, bar, baz","}","","struct Example: ParsableCommand {","    @Flag","    var booleanFlag = false","","    @Flag","    var arrayFlag: [CustomFlag] = [.foo, .baz]","","    @Option","    var singleOption = 0","","    @Option","    var arrayOption = [\"bar\", \"qux\"]","","    @Argument","    var singleArgument = \"quux\"","","    @Argument","    var arrayArgument = [\"quux\", \"quuz\"]","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This includes all of the variants of the argument types above (including "},{"type":"codeVoice","code":"@Option(transform: ...)"},{"type":"text","text":", etc.), with a few notable exceptions:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"Optional","type":"codeVoice"},{"text":"-typed values (which default to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" and for which a default would not make sense, as the value could never be ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"code":"Int","type":"codeVoice"},{"type":"text","text":" flags (which are used for counting the number of times a flag is specified and therefore default to "},{"code":"0","type":"codeVoice"},{"type":"text","text":")"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"If a default is not specified, the user must provide a value for that argument\/option\/flag or will receive an error that the value is missing.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You must also always specify a default of "},{"code":"false","type":"codeVoice"},{"type":"text","text":" for a non-optional "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a "},{"code":"struct","type":"codeVoice"},{"type":"text","text":"\/"},{"code":"class","type":"codeVoice"},{"type":"text","text":" containing them) and the other property types."}]},{"type":"heading","level":3,"text":"Specifying a parsing strategy","anchor":"Specifying-a-parsing-strategy"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When parsing a list of command-line inputs, "},{"code":"ArgumentParser","type":"codeVoice"},{"type":"text","text":" distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, this command defines a "},{"code":"--verbose","type":"codeVoice"},{"type":"text","text":" flag, a "},{"code":"--name","type":"codeVoice"},{"type":"text","text":" option, and an optional "},{"code":"file","type":"codeVoice"},{"type":"text","text":" argument:"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Option var name: String","    @Argument var file: String?","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When calling this command, the value for "},{"type":"codeVoice","code":"--name"},{"type":"text","text":" must be given immediately after the key. If the "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag is placed in between, parsing fails with an error:"}]},{"type":"codeListing","code":["% example --verbose --name Tomás","Verbose: true, name: Tomás, file: none","% example --name --verbose Tomás","Error: Missing value for '--name <name>'","Usage: example [--verbose] --name <name> [<file>]","  See 'example --help' for more information."],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"Parsing options as arrays is similar — only adjacent key-value pairs are recognized by default.","type":"text"}]},{"type":"heading","level":4,"text":"Alternative single-value parsing strategies","anchor":"Alternative-single-value-parsing-strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can change this behavior by providing a different parsing strategy in the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" initializer. "},{"inlineContent":[{"type":"text","text":"Be careful when selecting any of the alternative parsing strategies"}],"type":"strong"},{"type":"text","text":" — they may lead your command-line tool to have unexpected behavior for users!"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":".unconditional","type":"codeVoice"},{"text":" parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" were instead defined as ","type":"text"},{"code":"@Option(parsing: .unconditional) var name: String","type":"codeVoice"},{"text":", the second attempt would result in ","type":"text"},{"code":"\"--verbose\"","type":"codeVoice"},{"text":" being read as the value of ","type":"text"},{"code":"name","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","code":["% example --name --verbose Tomás","Verbose: false, name: --verbose, file: Tomás"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":".scanningForValue"},{"text":" strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" were defined as ","type":"text"},{"type":"codeVoice","code":"@Option(parsing: .scanningForValue) var name: String"},{"text":", the parser would look ahead to find ","type":"text"},{"type":"codeVoice","code":"Tomás"},{"text":", then pick up parsing where it left off to get the ","type":"text"},{"type":"codeVoice","code":"--verbose"},{"text":" flag:","type":"text"}]},{"type":"codeListing","code":["% example --name --verbose Tomás","Verbose: true, name: Tomás, file: none"],"syntax":null},{"type":"heading","level":4,"text":"Alternative array parsing strategies","anchor":"Alternative-array-parsing-strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Option var file: [String] = []","    @Flag var verbose = false","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(file)\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with single values, each time the user provides the "},{"type":"codeVoice","code":"--file"},{"type":"text","text":" key, they must also provide a value:"}]},{"type":"codeListing","code":["% example --verbose --file file1.swift --file file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file --verbose file1.swift --file file2.swift","Error: Missing value for '--file <file>'","Usage: example [--file <file> ...] [--verbose]","  See 'example --help' for more information."],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":".unconditionalSingleValue","type":"codeVoice"},{"text":" parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If ","type":"text"},{"code":"file","type":"codeVoice"},{"text":" were defined as ","type":"text"},{"code":"@Option(parsing: .unconditionalSingleValue) var file: [String]","type":"codeVoice"},{"text":", then the resulting array could include strings that look like options:","type":"text"}]},{"type":"codeListing","code":["% example --file file1.swift --file --verbose","Verbose: false, files: [\"file1.swift\", \"--verbose\"]"],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":".upToNextOption","type":"codeVoice"},{"text":" parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If ","type":"text"},{"code":"file","type":"codeVoice"},{"text":" were defined as ","type":"text"},{"code":"@Option(parsing: .upToNextOption) var file: [String]","type":"codeVoice"},{"text":", then the user could specify multiple files without repeating ","type":"text"},{"code":"--file","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","code":["% example --file file1.swift file2.swift","Verbose: false, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, the "},{"type":"codeVoice","code":".remaining"},{"type":"text","text":" parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .remaining) var file: [String]"},{"type":"text","text":", then the user would need to specify "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" before the "},{"type":"codeVoice","code":"--file"},{"type":"text","text":" key for it to be recognized as a flag:"}]},{"type":"codeListing","code":["% example --verbose --file file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]"],"syntax":null},{"type":"heading","level":4,"text":"Alternative positional argument parsing strategies","anchor":"Alternative-positional-argument-parsing-strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag and a list of file names as positional arguments:"}]},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Argument var files: [String] = []","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(files)\")","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"files"},{"type":"text","text":" argument array uses the default "},{"type":"codeVoice","code":".remaining"},{"type":"text","text":" parsing strategy, so it only picks up values that don’t have a prefix:"}]},{"type":"codeListing","code":["% example --verbose file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --verbose file1.swift file2.swift --other","Error: Unexpected argument '--other'","Usage: example [--verbose] [<files> ...]","  See 'example --help' for more information."],"syntax":null},{"type":"paragraph","inlineContent":[{"text":"Any input after the ","type":"text"},{"code":"--","type":"codeVoice"},{"text":" terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:","type":"text"}]},{"type":"codeListing","code":["% example --verbose -- file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":".unconditionalRemaining","type":"codeVoice"},{"text":" parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If ","type":"text"},{"code":"files","type":"codeVoice"},{"text":" were defined as ","type":"text"},{"code":"@Argument(parsing: .unconditionalRemaining) var files: [String]","type":"codeVoice"},{"text":", then the resulting array would also include strings that look like options:","type":"text"}]},{"type":"codeListing","code":["% example --verbose file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]","% example -- --verbose file1.swift file2.swift --other","Verbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]"],"syntax":null},{"level":4,"anchor":"Ignoring-unknown-arguments","type":"heading","text":"Ignoring unknown arguments"},{"inlineContent":[{"type":"text","text":"Different versions of a CLI tool may have full or partial sets of supported flags and options."}],"type":"paragraph"},{"inlineContent":[{"text":"By default, ","type":"text"},{"code":"ArgumentParser","type":"codeVoice"},{"text":" throws an error if unknown arguments are passed as command input.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"When appropriate, you can process supported arguments and ignore unknown ones by collecting unknowns in special "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":" with the "},{"type":"codeVoice","code":".allUnrecognized"},{"type":"text","text":" strategy."}],"type":"paragraph"},{"type":"codeListing","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    ","    @Argument(parsing: .allUnrecognized)","    var unknowns: [String] = []","","    func run() throws {","        print(\"Verbose: \\(verbose)\")","    }","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This way any unknown parameters are silently captured in the "},{"type":"codeVoice","code":"unknowns"},{"type":"text","text":" array."}],"type":"paragraph"},{"type":"codeListing","code":["% example --flag --verbose --option abc file1.swift","Verbose: true"],"syntax":null}]}],"abstract":[{"text":"Use the ","type":"text"},{"code":"@Argument","type":"codeVoice"},{"text":", ","type":"text"},{"code":"@Option","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"@Flag","type":"codeVoice"},{"text":" property wrappers to declare the command-line interface for your command.","type":"text"}],"kind":"article","seeAlsoSections":[{"anchor":"Arguments-Options-and-Flags","title":"Arguments, Options, and Flags","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"],"generated":true}],"variants":[{"paths":["\/documentation\/argumentparser\/declaringarguments"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/DeclaringArguments","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"references":{"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OptionGroup","kind":"identifier"}],"kind":"symbol","title":"OptionGroup","abstract":[{"text":"A wrapper that transparently includes a parsable type.","type":"text"}],"url":"\/documentation\/argumentparser\/optiongroup","role":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","type":"topic","navigatorTitle":[{"text":"OptionGroup","kind":"identifier"}]},"doc://ArgumentParser/documentation/ArgumentParser/EnumerableFlag":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EnumerableFlag","kind":"identifier"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","url":"\/documentation\/argumentparser\/enumerableflag","navigatorTitle":[{"text":"EnumerableFlag","kind":"identifier"}],"title":"EnumerableFlag","abstract":[{"text":"A type that represents the different possible flags to be used by a","type":"text"},{"text":" ","type":"text"},{"code":"@Flag","type":"codeVoice"},{"text":" property.","type":"text"}],"type":"topic","role":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/Option":{"type":"topic","title":"Option","abstract":[{"text":"A property wrapper that represents a command-line option.","type":"text"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Option"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Option"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","url":"\/documentation\/argumentparser\/option","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/Validation":{"abstract":[{"type":"text","text":"Provide helpful feedback to users when things go wrong."}],"role":"article","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation","title":"Providing Custom Validation","type":"topic","kind":"article","url":"\/documentation\/argumentparser\/validation"},"doc://ArgumentParser/documentation/ArgumentParser/Argument":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Argument","kind":"identifier"}],"title":"Argument","abstract":[{"text":"A property wrapper that represents a positional command-line argument.","type":"text"}],"role":"symbol","kind":"symbol","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","url":"\/documentation\/argumentparser\/argument","navigatorTitle":[{"text":"Argument","kind":"identifier"}]},"doc://ArgumentParser/documentation/ArgumentParser/Flag":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Flag","kind":"identifier"}],"abstract":[{"text":"A property wrapper that represents a command-line flag.","type":"text"}],"navigatorTitle":[{"text":"Flag","kind":"identifier"}],"type":"topic","url":"\/documentation\/argumentparser\/flag","title":"Flag","role":"symbol","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","type":"topic","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"url":"\/documentation\/argumentparser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument","kind":"symbol","abstract":[{"type":"text","text":"A type that can be expressed as a command-line argument."}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ExpressibleByArgument","kind":"identifier"}],"type":"topic","url":"\/documentation\/argumentparser\/expressiblebyargument","role":"symbol","navigatorTitle":[{"text":"ExpressibleByArgument","kind":"identifier"}],"title":"ExpressibleByArgument"},"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument/init(argument:)":{"fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"?("},{"kind":"externalParam","text":"argument"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":")"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)","role":"symbol","type":"topic","required":true,"kind":"symbol","url":"\/documentation\/argumentparser\/expressiblebyargument\/init(argument:)","title":"init(argument:)","abstract":[{"type":"text","text":"Creates a new instance of this type from a command-line-specified"},{"type":"text","text":" "},{"type":"text","text":"argument."}]},"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/argumentparser\/parsablearguments","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableArguments"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","title":"ParsableArguments","abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}],"navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}]}}}