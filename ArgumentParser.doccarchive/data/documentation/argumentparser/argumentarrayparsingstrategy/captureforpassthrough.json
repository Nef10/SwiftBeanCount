{"kind":"symbol","seeAlsoSections":[{"anchor":"Parsing-Strategies","title":"Parsing Strategies","generated":true,"identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/allUnrecognized","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/postTerminator"]}],"abstract":[{"type":"text","text":"Parse all remaining inputs after parsing any known options or flags,"},{"type":"text","text":" "},{"type":"text","text":"including dash-prefixed inputs and the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" terminator."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/captureForPassthrough"},"metadata":{"roleHeading":"Type Property","role":"symbol","symbolKind":"property","externalID":"s:14ArgumentParser0A20ArrayParsingStrategyV21captureForPassthroughACvpZ","modules":[{"name":"ArgumentParser"}],"title":"captureForPassthrough","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"captureForPassthrough","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV","text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier"}]},"sections":[],"schemaVersion":{"minor":3,"major":0,"patch":0},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy"]]},"primaryContentSections":[{"declarations":[{"tokens":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"captureForPassthrough","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV","text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy"},{"text":" { ","kind":"text"},{"text":"get","kind":"keyword"},{"text":" }","kind":"text"}],"platforms":["macOS"],"languages":["swift"]}],"kind":"declarations"},{"kind":"content","content":[{"level":2,"type":"heading","text":"Discussion","anchor":"discussion"},{"type":"paragraph","inlineContent":[{"text":"You can use the ","type":"text"},{"code":"captureForPassthrough","type":"codeVoice"},{"text":" parsing strategy if you need to","type":"text"},{"text":" ","type":"text"},{"text":"capture a userâ€™s input to manually pass it unchanged to another command.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you use this parsing strategy, the parser stops parsing flags and"},{"type":"text","text":" "},{"type":"text","text":"options as soon as it encounters a positional argument or an unrecognized"},{"type":"text","text":" "},{"type":"text","text":"flag, and captures all remaining inputs in the array argument."}]},{"type":"paragraph","inlineContent":[{"text":"For example, the ","type":"text"},{"type":"codeVoice","code":"Example"},{"text":" command defined below has an ","type":"text"},{"type":"codeVoice","code":"words"},{"text":" array that","type":"text"},{"text":" ","type":"text"},{"text":"uses the ","type":"text"},{"type":"codeVoice","code":"captureForPassthrough"},{"text":" parsing strategy:","type":"text"}]},{"code":["@main","struct Example: ParsableCommand {","    @Flag var verbose = false","","    @Argument(parsing: .captureForPassthrough)","    var words: [String] = []","","    func run() {","        print(words.joined(separator: \"\\n\"))","    }","}"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any values after the first unrecognized input are captured in the "},{"code":"words","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"array."}]},{"code":["$ example --verbose one two --other","one","two","--other","$ example one two --verbose","one","two","--verbose"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"With the ","type":"text"},{"code":"captureForPassthrough","type":"codeVoice"},{"text":" parsing strategy, the ","type":"text"},{"code":"--","type":"codeVoice"},{"text":" terminator","type":"text"},{"text":" ","type":"text"},{"text":"is included in the captured values.","type":"text"}]},{"code":["$ example --verbose one two -- --other","one","two","--","--other"],"type":"codeListing","syntax":null},{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"This parsing strategy can be surprising for users, particularly"},{"type":"text","text":" "},{"type":"text","text":"when combined with options and flags. Prefer "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","isActive":true},{"type":"text","text":" or"},{"type":"text","text":" "},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/allUnrecognized","isActive":true},{"type":"text","text":" whenever possible, since users can always terminate"},{"type":"text","text":" "},{"type":"text","text":"options and flags with the "},{"type":"codeVoice","code":"--"},{"text":" terminator. With the ","type":"text"},{"type":"codeVoice","code":"remaining"},{"text":" ","type":"text"},{"text":"parsing strategy, the input ","type":"text"},{"type":"codeVoice","code":"--verbose -- one two --other"},{"text":" would have","type":"text"},{"text":" ","type":"text"},{"text":"the same result as the first example above.","type":"text"}],"type":"paragraph"}],"name":"Note"}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/argumentarrayparsingstrategy\/captureforpassthrough"]}],"references":{"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/allUnrecognized":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/allUnrecognized","kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/allunrecognized","title":"allUnrecognized","type":"topic","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"allUnrecognized","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"abstract":[{"text":"After parsing, capture all unrecognized inputs in this argument array.","type":"text"}]},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/captureForPassthrough":{"title":"captureForPassthrough","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/captureforpassthrough","kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/captureForPassthrough","abstract":[{"type":"text","text":"Parse all remaining inputs after parsing any known options or flags,"},{"type":"text","text":" "},{"type":"text","text":"including dash-prefixed inputs and the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" terminator."}],"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"captureForPassthrough","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy":{"kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ArgumentArrayParsingStrategy"}],"navigatorTitle":[{"kind":"identifier","text":"ArgumentArrayParsingStrategy"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy","type":"topic","title":"ArgumentArrayParsingStrategy","abstract":[{"text":"The strategy to use when parsing multiple values from positional arguments","type":"text"},{"text":" ","type":"text"},{"text":"into an array.","type":"text"}],"role":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/remaining":{"abstract":[{"text":"Parse only unprefixed values from the command-line input, ignoring","type":"text"},{"text":" ","type":"text"},{"text":"any inputs that have a dash prefix; this is the default strategy.","type":"text"}],"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"remaining","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"title":"remaining","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/remaining","role":"symbol","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/postTerminator":{"kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/postterminator","title":"postTerminator","role":"symbol","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/postTerminator","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"postTerminator","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV","text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"Before parsing arguments, capture all inputs that follow the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" "},{"type":"text","text":"terminator in this argument array."}]},"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","type":"topic","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"url":"\/documentation\/argumentparser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol"}}}