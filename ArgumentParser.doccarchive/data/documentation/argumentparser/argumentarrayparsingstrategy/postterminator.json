{"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy"]]},"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/postTerminator"},"abstract":[{"text":"Before parsing arguments, capture all inputs that follow the ","type":"text"},{"code":"--","type":"codeVoice"},{"text":" ","type":"text"},{"text":"terminator in this argument array.","type":"text"}],"metadata":{"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"postTerminator","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV","text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier"}],"symbolKind":"property","modules":[{"name":"ArgumentParser"}],"role":"symbol","roleHeading":"Type Property","title":"postTerminator","externalID":"s:14ArgumentParser0A20ArrayParsingStrategyV14postTerminatorACvpZ"},"kind":"symbol","primaryContentSections":[{"declarations":[{"tokens":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"postTerminator"},{"kind":"text","text":": "},{"kind":"typeIdentifier","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy","text":"ArgumentArrayParsingStrategy","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"},{"kind":"text","text":" { "},{"kind":"keyword","text":"get"},{"kind":"text","text":" }"}],"platforms":["macOS"],"languages":["swift"]}],"kind":"declarations"},{"content":[{"type":"heading","text":"Discussion","level":2,"anchor":"discussion"},{"inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"Example"},{"type":"text","text":" command defined below has a "},{"type":"codeVoice","code":"words"},{"type":"text","text":" array that"},{"type":"text","text":" "},{"type":"text","text":"uses the "},{"type":"codeVoice","code":"postTerminator"},{"type":"text","text":" parsing strategy:"}],"type":"paragraph"},{"code":["@main","struct Example: ParsableCommand {","    @Flag var verbose = false","    @Argument var name = \"\"","","    @Argument(parsing: .postTerminator)","    var words: [String]","","    func run() {","        print(words.joined(separator: \"\\n\"))","    }","}"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Before looking for the "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag and "},{"type":"codeVoice","code":"<name>"},{"type":"text","text":" argument, any inputs"},{"type":"text","text":" "},{"type":"text","text":"after the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" terminator are captured into the "},{"type":"codeVoice","code":"words"},{"type":"text","text":" array."}],"type":"paragraph"},{"code":["$ example --verbose Asa -- one two --other","one","two","--other","$ example Asa Extra -- one two --other","Error: Unexpected argument 'Extra'"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"text":"Because options are parsed before arguments, an option that consumes or","type":"text"},{"text":" ","type":"text"},{"text":"suppresses the ","type":"text"},{"code":"--","type":"codeVoice"},{"text":" terminator can prevent a ","type":"text"},{"code":"postTerminator","type":"codeVoice"},{"text":" argument","type":"text"},{"text":" ","type":"text"},{"text":"array from capturing any input. In particular, the","type":"text"},{"text":" ","type":"text"},{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/SingleValueParsingStrategy\/unconditional","type":"reference","isActive":true},{"type":"text","text":","},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArrayParsingStrategy\/unconditionalSingleValue"},{"type":"text","text":", and"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArrayParsingStrategy\/remaining"},{"type":"text","text":" parsing strategies can all consume"},{"type":"text","text":" "},{"type":"text","text":"the terminator as part of their values."}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"This parsing strategy can be surprising for users, since it","type":"text"},{"text":" ","type":"text"},{"text":"changes the behavior of the ","type":"text"},{"type":"codeVoice","code":"--"},{"text":" terminator. Prefer ","type":"text"},{"type":"reference","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","isActive":true},{"text":" ","type":"text"},{"text":"whenever possible.","type":"text"}],"type":"paragraph"}],"name":"Note"}],"kind":"content"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"seeAlsoSections":[{"generated":true,"anchor":"Parsing-Strategies","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/allUnrecognized","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/captureForPassthrough"],"title":"Parsing Strategies"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/argumentparser\/argumentarrayparsingstrategy\/postterminator"]}],"references":{"doc://ArgumentParser/documentation/ArgumentParser":{"title":"ArgumentParser","role":"collection","type":"topic","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"url":"\/documentation\/argumentparser","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy":{"kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ArgumentArrayParsingStrategy"}],"navigatorTitle":[{"kind":"identifier","text":"ArgumentArrayParsingStrategy"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy","type":"topic","title":"ArgumentArrayParsingStrategy","abstract":[{"text":"The strategy to use when parsing multiple values from positional arguments","type":"text"},{"text":" ","type":"text"},{"text":"into an array.","type":"text"}],"role":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/captureForPassthrough":{"title":"captureForPassthrough","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/captureforpassthrough","kind":"symbol","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/captureForPassthrough","abstract":[{"type":"text","text":"Parse all remaining inputs after parsing any known options or flags,"},{"type":"text","text":" "},{"type":"text","text":"including dash-prefixed inputs and the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" terminator."}],"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"captureForPassthrough","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"type":"topic"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/remaining":{"abstract":[{"text":"Parse only unprefixed values from the command-line input, ignoring","type":"text"},{"text":" ","type":"text"},{"text":"any inputs that have a dash prefix; this is the default strategy.","type":"text"}],"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"remaining","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"title":"remaining","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/remaining","role":"symbol","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/remaining","kind":"symbol"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/postTerminator":{"kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/postterminator","title":"postTerminator","role":"symbol","type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/postTerminator","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"postTerminator","kind":"identifier"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV","text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"Before parsing arguments, capture all inputs that follow the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" "},{"type":"text","text":"terminator in this argument array."}]},"doc://ArgumentParser/documentation/ArgumentParser/SingleValueParsingStrategy/unconditional":{"role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"unconditional"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"SingleValueParsingStrategy","preciseIdentifier":"s:14ArgumentParser26SingleValueParsingStrategyV"}],"type":"topic","identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/SingleValueParsingStrategy\/unconditional","title":"unconditional","abstract":[{"type":"text","text":"Parse the next input, even if it could be interpreted as an option or"},{"type":"text","text":" "},{"type":"text","text":"flag."}],"kind":"symbol","url":"\/documentation\/argumentparser\/singlevalueparsingstrategy\/unconditional"},"doc://ArgumentParser/documentation/ArgumentParser/ArgumentArrayParsingStrategy/allUnrecognized":{"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArgumentArrayParsingStrategy\/allUnrecognized","kind":"symbol","url":"\/documentation\/argumentparser\/argumentarrayparsingstrategy\/allunrecognized","title":"allUnrecognized","type":"topic","role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"allUnrecognized","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArgumentArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser0A20ArrayParsingStrategyV"}],"abstract":[{"text":"After parsing, capture all unrecognized inputs in this argument array.","type":"text"}]},"doc://ArgumentParser/documentation/ArgumentParser/ArrayParsingStrategy/remaining":{"abstract":[{"text":"Parse all remaining arguments into an array.","type":"text"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArrayParsingStrategy\/remaining","type":"topic","kind":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"remaining","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser20ArrayParsingStrategyV"}],"role":"symbol","url":"\/documentation\/argumentparser\/arrayparsingstrategy\/remaining","title":"remaining"},"doc://ArgumentParser/documentation/ArgumentParser/ArrayParsingStrategy/unconditionalSingleValue":{"type":"topic","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"unconditionalSingleValue","kind":"identifier"},{"text":": ","kind":"text"},{"text":"ArrayParsingStrategy","kind":"typeIdentifier","preciseIdentifier":"s:14ArgumentParser20ArrayParsingStrategyV"}],"abstract":[{"text":"Parse the value immediately after the option while allowing repeating options, joining multiple into an array.","type":"text"}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ArrayParsingStrategy\/unconditionalSingleValue","url":"\/documentation\/argumentparser\/arrayparsingstrategy\/unconditionalsinglevalue","role":"symbol","kind":"symbol","title":"unconditionalSingleValue"}}}